
import fs from 'fs';
import path from 'path';
import { DynamicReflex } from './DynamicReflex.js'; // Ensure this class handles JS-based reflexes or is adapted

export class ReflexCreatorEngine {
    constructor(agent) {
        this.agent = agent;
        this.reflexes = new Map();
        this.dynamicPath = path.join(process.cwd(), 'src/reflexes/dynamic');

        if (!fs.existsSync(this.dynamicPath)) {
            fs.mkdirSync(this.dynamicPath, { recursive: true });
        }
    }

    async init() {
        await this.loadReflexes();
    }

    async loadReflexes() {
        this.reflexes.clear();
        console.log('[ReflexCreator] Loading dynamic reflexes from:', this.dynamicPath);

        try {
            const files = fs.readdirSync(this.dynamicPath).filter(f => f.endsWith('.js') && f.startsWith('dr_'));

            for (const file of files) {
                try {
                    const filePath = `file://${path.join(this.dynamicPath, file)}`;
                    const module = await import(filePath);

                    if (module.default && module.default.id) {
                        // Adapt JS module to DynamicReflex structure if needed
                        const reflex = new DynamicReflex({
                            ...module.default,
                            source: 'file_loaded',
                            filePath: path.join(this.dynamicPath, file)
                        });
                        this.reflexes.set(reflex.id, reflex);
                        console.log(`[ReflexCreator] Loaded: ${reflex.id}`);
                    }
                } catch (e) {
                    console.error(`[ReflexCreator] Failed to load ${file}:`, e);
                }
            }
            return Array.from(this.reflexes.values());
        } catch (err) {
            console.error('[ReflexCreator] Error scanning directory:', err);
            return [];
        }
    }

    /**
     * Analyze death and create a new JS reflex
     */
    async analyzeAndCreate(deathAnalysis) {
        if (!deathAnalysis?.cause) return null;

        const reflexId = `dr_${deathAnalysis.cause.replace(/\s+/g, '_').toLowerCase()}`;
        if (this.reflexes.has(reflexId)) return null; // Already evolved

        console.log(`[ReflexCreator] Evolving reflex for: ${deathAnalysis.cause}`);

        // 1. Generate Code via Brain
        const brain = this.agent?.brain;
        if (brain && brain.generateCode) {
            const prompt = this._buildPrompt(deathAnalysis, reflexId);
            const code = await brain.generateCode(prompt);
            const cleanCode = this._extractCodeBlock(code);

            if (cleanCode) {
                const success = await this._saveReflexFile(reflexId, cleanCode);
                if (success) {
                    // Hot-reload
                    return await this._hotLoad(reflexId);
                }
            }
        }
        return null;
    }

    _extractCodeBlock(response) {
        const match = response.match(/```javascript([\s\S]*?)```/);
        return match ? match[1].trim() : response; // Fallback to raw if no blocks
    }

    async _saveReflexFile(id, codeBody) {
        // Wrap in standard ESM template
        const fileContent = `
/**
 * Dynamic Reflex: ${id}
 * Generated by Evolution Engine
 */
export default {
    id: "${id}",
    name: "${id.replace('dr_', 'Anti-')}",
    trigger: {
        signal: 'THREAT_DETECTED' // Default, AI should have customized this in codeBody logic? 
        // Actually, the prompt should request the WHOLE object export.
    },
    action: async (agent, payload) => {
        const bot = agent.bot;
        ${codeBody}
    }
};
`;
        // Wait, prompt request strategy needs to align.
        // If I ask for just the function body, I wrap it.
        // If I ask for the whole file, I write it.
        // Let's ask for the function body for safety and wrap it here.

        const filePath = path.join(this.dynamicPath, `${id}.js`);
        try {
            fs.writeFileSync(filePath, fileContent);
            console.log(`[ReflexCreator] Saved to ${filePath}`);
            return true;
        } catch (e) {
            console.error('[ReflexCreator] Write failed:', e);
            return false;
        }
    }

    async _hotLoad(id) {
        const filePath = `file://${path.join(this.dynamicPath, `${id}.js`)}`;
        try {
            const module = await import(filePath);
            const reflex = new DynamicReflex(module.default);
            this.reflexes.set(id, reflex);

            if (this.agent.core?.reflexSystem) {
                this.agent.core.reflexSystem.registerDynamicReflex(reflex);
            }
            return reflex;
        } catch (e) {
            console.error('[ReflexCreator] Hot-load failed:', e);
            return null;
        }
    }

    _buildPrompt(deathAnalysis, id) {
        return `You are the Evolution Engine.
Create a JavaScript function body for a Mineflayer bot to survive: ${deathAnalysis.cause}.
Context: ${JSON.stringify(deathAnalysis.context)}

Requirements:
- Variable 'bot' is available.
- Variable 'agent' is available.
- Use 'await' where needed.
- Return nothing.
- Code must be robust and handle errors.

Example:
// For fall damage
if (bot.entity.velocity.y < -0.6) {
    const water = bot.findBlock({ matching: CONFIG.WATER, maxDistance: 32 });
    if (water) await bot.lookAt(water.position);
}

Generate ONLY the code body. No markdown.`;
    }
}
