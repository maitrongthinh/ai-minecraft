
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * ToolCreatorEngine: Phase 7 Dynamic Skill Generation
 * 
 * Orchestrates the creation of new MCP-compatible skills/tools
 * using the UnifiedBrain's high-IQ model.
 */
export class ToolCreatorEngine {
    constructor(agent) {
        this.agent = agent;
        // Use KnowledgeStore path if available, fallback to default
        this.dynamicSkillsPath = this.agent.knowledge
            ? this.agent.knowledge.getPath('created_tools')
            : path.join(__dirname, '../../../src/skills/library/dynamic');

        // Ensure directory exists
        if (!fs.existsSync(this.dynamicSkillsPath)) {
            fs.mkdirSync(this.dynamicSkillsPath, { recursive: true });
        }

        console.log('[ToolCreator] Initialized');
    }

    /**
     * Create a new tool for a specific need
     * @param {string} need - Description of what the tool should do
     * @param {string} context - Context about why it's needed (e.g. "Failed to craft X")
     * @returns {Promise<boolean>} Success
     */
    async createTool(need, context = '') {
        console.log(`[ToolCreator] ðŸ› ï¸ Generating tool for: "${need}"`);

        try {
            // 1. Generate Tool Definition via Brain
            const toolDef = await this.agent.brain.generateTool(need, context);

            if (!toolDef || !toolDef.schema || !toolDef.code) {
                throw new Error('Brain returned invalid tool definition');
            }

            const { schema, code } = toolDef;
            const name = schema.name;

            // 2. Validate Tool Name
            if (!/^[a-z0-9_]+$/.test(name)) {
                throw new Error(`Invalid tool name "${name}". Must be snake_case.`);
            }

            // 3. Safety Sandwich Validation (Phase 6)
            if (this.agent.evolution?.safety) {
                console.log(`[ToolCreator] ðŸ›¡ï¸ Validating code for ${name}...`);
                const validation = await this.agent.evolution.safety.validate(code);
                if (!validation.valid) {
                    throw new Error(`Safety Validation Failed: ${validation.reasoning}`);
                }
            }

            // 4. Construct File Content
            const fileContent = this._buildFileContent(schema, code);

            // 5. Save to Disk
            const filePath = path.join(this.dynamicSkillsPath, `${name}.js`);
            fs.writeFileSync(filePath, fileContent);
            console.log(`[ToolCreator] ðŸ’¾ Saved tool to ${filePath}`);

            // 6. Register with ToolRegistry (Hot Reload)
            try {
                await this.agent.toolRegistry._loadSkill(filePath);

                this.agent.bot.chat(`I've learned a new skill: ${name}!`);

                // Register with KnowledgeStore
                if (this.agent.knowledge) {
                    this.agent.knowledge.registerTool(name, schema.description, {
                        source: 'tool_creator',
                        path: filePath
                    });
                }

                return true;

            } catch (regErr) {
                console.error('[ToolCreator] Registration failed:', regErr);
                // Rollback (Delete broken file)
                if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
                return false;
            }

        } catch (error) {
            console.error('[ToolCreator] Tool generation failed:', error.message);
            this.agent.bot.chat(`I tried to create a tool for that, but: ${error.message}`);
            return false;
        }
    }

    _buildFileContent(schema, code) {
        // Clean code (remove async if double wrapping occurs)
        let cleanCode = code.trim();
        if (cleanCode.startsWith('async (agent, params) =>')) {
            // format is good
        } else if (cleanCode.startsWith('async function')) {
            // might be named, convert to arrow or anonymous
        }

        // We wrap the code implementation in a default export

        return `
/**
 * ${schema.description}
 * Generated by ToolCreatorEngine
 */

export const metadata = {
    name: '${schema.name}',
    description: '${schema.description}',
    parameters: ${JSON.stringify(schema.parameters, null, 4)},
    tags: ['dynamic', 'generated'],
    usageCount: 0
};

export default ${cleanCode};
`;
    }
}
